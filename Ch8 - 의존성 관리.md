###### 1) 바람직한 의존성

의존성 관리의 목적은 **유연하고 재사용 가능** 하도록 만드는 것이다.

>##*내 요약*
>추상화에 의존 → 컨텍스트 독립 → 여러 문맥(컨텍스트)에서 **재사용** 가능
>재 사용 가능 == 유연성

**추상화 정도**
1. 구체 클래스 의존성(concrete class dependency)
2. 추상 클래스 의존성(abstract class dependency)
3. 인터페이스 의존성(interface dependency)

*ref.*
[[오브젝트08-11_OCR.pdf#page=15]]


###### 2) 의존성 해결 방법

**1) 생성자** → 객체 생성 시점
**2) Setter** → 객체 생성 후 Setter 사용
**3) 메서드 인자** →지속적인 의존관계가 필요 없는 경우

*ref.*
[[오브젝트08-11_OCR.pdf#page=9]]


##### 3) 명시적인 의존성 & 숨겨진 의존성

###### 3.1) 명시적인 의존성

**정의**
+ 의존성이 명시적으로 퍼블릭 인터페이스에 노출된다.

>의존성은 거의 대부분 명시적으로 드러내자.
>
>##*내 생각*
>왜냐하면, 개발자가 Context를 확인 하기 위해서는 의존성을 확인 해야 한다.
>
>*ex.* 
>1. 영화의 할인 정책 → 고정 금액 할인 OR 비율 할인 정책
>2. 할인정책 확인 방법 → 의존성 확인 필요
>3. **하지만, 의존성을 숨겨 놓으면 문맥을 확인하기 위해 구현을 찾아봐야 한다.**

###### 3.2) 숨겨진 의존성

**정의**
+ 클래스 내부에서 인스턴스를 생성해서 의존한다.

**단점**
+ 다른 문맥에서 사용되기 위해서는 의존성을 변경 필요
  → But 의존성이 클래스 내부에 존재
  → 따라서, 클래스 내부 확인 필요

**new 사용의 단점**
+ new 구체 클래스 이름 
  → 추상화가 아닌 구체 클래스 의존
+ new 클래스 이름( 인자 전달)
  → 생성하는 클래스의 인자까지 알아야 한다.
  → 알아야 하는 지식의 양이 증가
  → 결합도 증가

>*cf.*
>표준 클래스는 변경 가능성이 없기 거의 없기 때문에 의존해도 상관없다.



*ref.*
+ 숨겨진 의존성
	+ [[오브젝트08-11_OCR.pdf#page=16]]
+ new 사용 단점
	+ [[오브젝트08-11_OCR.pdf#page=19]]

