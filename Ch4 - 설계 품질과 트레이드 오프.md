
###### 1) 캡슐화

**정의**
+ 불안정한 부분과 안정적인 부분을 분리 
  → 변경의 영향을 통제
+ 변경 가능성이 높은 부분은 객체 내부로 숨긴다.
	+ 변경 가능성 높은 부분 → 구현
	+ 안정적인 부분 → 인터페이스

*ref.*
[[오브젝트04-08.pdf#page=12]]

**핵심**
+ 캡슐화 정도 → 응집도 & 결합도 영향
+ 따라서, 캡슐화를 향상시키기 위한 고민을 하면 된다.

###### 1.1) 응집도
+ 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도

**낮은 응집도** 
→ 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존

**낮은 응집도 문제**
+ 변경의 이유가 서로 다른 코드들이 하나의 모듈 안에 존재 
  → 변경과 상관없는 코드들이 영향을 받게 된다.
+ 하나의 요구 사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다
  → 책임이 여러 모듈 여기저기 흩어져 있다.

*ref.*
[[오브젝트04-08.pdf#page=14]]
[[오브젝트04-08.pdf#page=20]]

###### 1.2) 결합도
+ 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
+ 변경될 확률이 매우 적은 안정적인 모듈에 의존하
는 것은 아무런 문제가 되지 않는다.
> *ex.*
> Java의 String 또는 ArrayList

*ref.*
[[오브젝트04-08.pdf#page=15]]


###### 2) 캡슐화 위반

```
public class DiscountCondition {

    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

	public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {
		//...내부 구현
    }
```
**문제점**
+ 인터페이스의 파라미터를 통해 내부 정보 노출
	+ DiscountCondition 객체에게 메세지를 보내려고 하면, DiscountCondition 내부 정보에 의존해야 한다.
+ `DiscountCondition` 의 속성을 변경하는 경우, 
  1. 인터페이스 변경 발생
  2. 사용하는 곳 코드 변경

**캡슐화의 의미**
변경될 수 있는 어떤 것이라도 감추는 것
> 내부 속성을 감추는 것 → 데이터 캡슐화

*ref.*
[[오브젝트04-08.pdf#page=30]]


> ##*내 생각*
> 결국, "==클라이언트가 보내는 메세지=="를 기준으로 객체를 정하면, 캡슐화는 자연스럽게 따라 오는 것 같다.
