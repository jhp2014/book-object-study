
###### 1) 상속 → 합성

**코드 재 사용을 하기 위해서는 상속 대신 합성을 사용하자**
>구현 상속을 피하고 인터페이스 상속을 사용해야 한다.

상속 :: is - a 
합성 :: has - a

>##*내 생각*
>"코드를 재 사용 한다." → 왜?
>+ 기존 기능에 부가 기능 추가
>  → **AOP**
>+ 기존 기능도 사용하고, 새로운 기능도 추가 
>  → **새로운 기능 장착**
>  
>  상속은 개념적으로 동일한 그룹으로 묶기 위해서 사용해야 한다.
>  *ex.*
>  도형 ↔ 삼각형, 사각형


###### 1.1) 상속 관계 변환 📌내 생각
상위 ↔ 하위 개념의 분류
+ 새로운 기능 장착
+ 기존 기능 업그레이드
+ 개념적 추상화

**1) 새로운 기능 장착**
+ 상속 관계 
  → "부모 클래스" has "자식 클래스" 형태
```
영화 (부모)
→ 금액 할인 정책 영화 (자식)
→ 비율 할인 정책 영화 (자식)

핸드폰 (부모)
→ 기본 할인 정책 핸드폰 (자식)
→ 심야 할인 정책 핸드폰 (자식)
```


**2) 기존 기능 업그레이드** → AOP
+ 상속 관계  
  → "자식 클래스" has "부모 클래스" 형태
```
Set (부모)
→ InstrumentHashSet (자식)

기본 할인 정책 (부모)
→ 기본요금 할인 정책 (자식)
```

**3) 개념적 추상화**
+ 상속 관계 그대로 사용
```
도형 (부모)
→ 삼각형
→ 사각형
```


###### 1.2) 공통 관심사 처리

**상속**
+ 공통 관심사가 들어간 모든 경우의 수를 상속으로 하나하나 만들어 주어야 한다.
> 컴파일 시점에 강하게 결합된다. 
> 유연하지 못하므로, 공통 관심사를 하나하나 코드에 추가해주어야 한다.

*ref.*
[[오브젝트08-11_OCR.pdf#page=114]]

**합성**
+ AOP 적용!

*ref.*
[[오브젝트08-11_OCR.pdf#page=121]]
