
###### 1) 설계의 일관성

**원칙**
1. 변하는 개념을 변하지 않는 개념으로부터 분리
2. 변하는 개념을 캡슐화 하라.

**변경의 기준**
+ 가장 중요한 기준은 변경의 이유
	+ 단일 책임 원칙

**예시**
+ `if ~ else` 을 다형성으로 변경

*ref.*
[[오브젝트12-END_OCR.pdf#page=83]]
변경 분리 :: [[오브젝트12-END_OCR.pdf#page=101]]
캡슐화 :: [[오브젝트12-END_OCR.pdf#page=108]]

###### 2) 변경 분리

**요구 사항**
+ 고정 요금 방식
+ 시간대 별 방식
+ 요일 별 방식
+ 구간 별 방식 


###### 2.1) 변경 분리 전

+ 시간대 별 방식
	+ 통화 기록 → 하루 단위로 분리
	+ 분리된 기록 → 시간대 별로 분리 & 계산
+ 요일 별 방식
	+ 통화 기록 → 하루 단위로 분리
	+ 분리된 기록 → 요일 조건에 따라 계산

**문제**
결국 요금을 계산하는 것이지만, 구현 방법이 다 다르다. 일관성이 없고 시간이 지나면 일관성은 더 어긋날 것이다. 그러면, 결국 **이해하기 어려워 진다.**
>유사한 기능을 서로 다른 방식으로 구현해서는 안 된다는 것이다


###### 2.2) 변하는 부분 분리 

**요구 사항**
![[핸드폰 요금 요구사항.png]]

**변하는 부분 사항 확인**
![[핸드폰 요금 변경사항 분리.png]]
+ 변하는 부분 → 적용 조건
	+ 따라서, 이 부분을 추상화 한다.
+ 변하지 않는 부분 → 규칙 :: `요금 / 단위시간`
> ##*내 생각*
>변하지 않는 부분을 확인 할때는 *틀*을 봐야 하는것 같다. 
>
>`10초당 18원, 10초당 20원` 이건 변한다고 판단하는 것이 아니다. 

**예제 요약**
```
RatePolicy
- List<FeeRule>
- 규칙들에게 요금 계산 요청

FeePerDuration
- 시간 전달받아서 단위 시간당 요금 계산
- 단위 시간당 요금 계산

FeeRule
- FeePerDuration
- FeeCondition
- Call을 FeeCondition에 주면서 조건에 맞는 시간 반환
```


*ref.*
[[오브젝트12-END_OCR.pdf#page=111]]
최종 결과 :: [[오브젝트12-END_OCR.pdf#page=123]]


###### 3) 지속적인 개선

+ 새로운 요구사항이 추가
  → 일관성이 조금씩 무너진다.
  → 자연스러운 현상 (초기에 모든 요구사항 예측 불가)
  → 따라서, 지속적으로 개선 필요
